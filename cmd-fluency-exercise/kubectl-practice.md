- Set alias for kubectl </br>$ alias k=kubectl
- Get kubectl version </br> $ k version --short
- Get info about a k8s object </br> $ k explain pod </br> $ k explain pod.spec
- Get yml structure of a k8s object </br> $ k explain pod --recursive
- Get cluster info </br> $ k cluster-info </br> 
- Get detailed view of cluster information </br> $ k cluster-info dump
- Get configuration </br> $ k config -h </br> k config view # View content of ~/.kube/config | /etc/kubernetes/admin.conf
- Get the config view from custom kubeconfig </br> $ k config view --kubeconfig=/root/my-kube-config
- Get contexts </br> $ k config get-contexts
- Get users </br> $ k config get-users
- Get all clusters </br> $ k config get-clusters
- **Display events for a given namespace** </br> $ k get events -n default
- schedule a pod and view the events to get which scheduler picked it up </br> $ k run httpd --image=httpd && k get events
- **Set bash completion**
   - echo "source <(kubectl completion bash)" >> ~/.bashrc
   - echo "export do='-o yaml --dry-run=client'" >> ~/.bashrc
   - source ~/.bashrc
- Set vimrc
   - set tabstop=2 shiftwidth=2 expandtab ai  
   - if you already have tabs ":retab"
- Connect to Kube API Server via proxy </br> $ k proxy # This lists API Groups
- Get the version of KAS via http call </br? k proxy &; curl http://localhost:8001/version; curl http://localhost:8001/api-resources
- How to troubleshoot kubelet and KAS </br> $ journalctl -u kubelet </br> $ journalctl -u kube-apiserver </br> sudo journalctl -u kubelet -f
- **Create a pod manifest for nginx  image with requests and limits and run a sleep command** </br> $ k run httpd -o yaml --dry-run=client --image=httpd --requests "cpu=100m,memory=256Mi" --limits "cpu=200m,memory=512Mi" --namespace=default --command --sh -c "sleep 300" > nginx.yml </br> kubectl run httpd -o yaml --dry-run=client --image=httpd --requests "cpu=100m,memory=150Mi" --limits "cpu=200m,memory=300Mi" --port=80 --hostport=80 --namespace=default -l name=httpd --restart=Never --command -- sleep 200
- Execute a command on a pod </br> $ k exec nginx -- date -s '19 APR 2012 11:14:00'
- Create an interactive shell on a pod </br> $ k run -it --rm --restart=Never busybox --image=busybox:1.28 sh </br> $ k exec -it nginx /bin/bash
- Get more details from nginx pod </br> $ k describe pod nginx
- Get labels of a pod and a node </br> $ k get pods --show-labels </br> $ k get nodes --show-labels
- Get node details of all pods </br> $ k get pods -o wide
- Get logs of a pod </br> $ k logs nginx
- Get logs of a container in pod </br> $ k logs nginx -c container1
- Get logs of previous version of pod </br> $ k logs -f --previous
- Continuously stream logs </br> $ k logs -f nginx [container]
- Select a pod matching labels env=prod and bu=finance </br> $ k get pods -l env=prod,bu=finance
- Edit nginx pod </br> $ k edit pod nginx
- To taint a node </br> $ k taint node <nodename> key=value:effect   # effect NoSchedule
- To untaint a node </br> $ k taint node <nodename> key=value:effect-
- Taint a node with taint effect NoSchedule </br> $ k taint nodes node01 key=app:NoSchedule
- To check all available options for tolerations </br> $ k explain pod --recursive | grep -A5 toelrations
- Label nodes with key as size and value as large </br> $ k label nodes node01 size=large
- Continuously inquire a pod </br> $ watch "kubectl get pods" 
- Inquire process at pod and node </br> $ k top node 01 </br> $ k top nginx
- Get Rollout state of a deployment </br> $ kubectl apply -f nginx.yml --record </br> $ k rollout status deployment/deployment-name
- Get Rollout history of a deployment </br> $ kubectl apply -f nginx.yml --record </br> $ k rollout history deployment/deployment-name
- Rollback a deployment </br> $ k rollout undo deployment/deployment-name
- To add tolerations, create pod yaml using declarative way and then copy three lines of containers section under spec and rename based on your requirements
- Create a namespace dummy </br> $ k create ns dummy
- Create a deployment for nginx with 3 replicas in prod namespace </br> $ k create ns prod </br> $ k create deployment nginx1 -o yaml --dry-run=client --image=nginx --replicas=3 --namespace=prod > mydeploy.yml </br> $ k create -f mydeploy.yml
- Scale the above deployment to 5 </br> $ kubectl scale deployment nginx --replicas=3 </br> alternatively update replicas to 5 in deployment manifest yaml
- Set a namespace dev as default namespace for the current context </br> $ k config set-context $(k config current-context) --namespace=dev
- Change to a different context </br> $ k config use-context prod-user@production
- Create/update/delete/apply resources from manifests </br> $k {create|replace|delete|apply} -f manifest.yml
- Count a list of entries from kubectl command </br> $ k get pods --no-headers |wc -l
- Create a Service named nginx of type NodePort to expose pod nginx's port 80 on port 30080 on the nodes </br> $ k expose pod nginx -o yaml --dry-run=client --port=80 --name nginx-service --type=NodePort </br> after port 80 add "nodePort: 30080"
- Create a Service named nginx of type ClusterIP to expose pod nginx's port 6379 </br> $ k expose pod nginx -o yaml --dry-run=client --port=6379 --name nginx-service 
- Create a service named nginx-service for a deployment named nginx </br> $ k expose deployment nginx -o yaml --dry-run=client --port 80 --name nginx-service --type=NodePort   # Note to add nodePort in yaml before creating the service
- Create a pod and a service in one shot </br> $ k run httpd --image=httpd:alpine --port=80 --expose 
- To replace a resource from yaml </br> $ k replace --force -f manifest.yml
- To update a deployment with a new image </br> $ k set image deployment/deployment-name <container-name>=nginx:1.9.1

- Create a configMap from literal </br> $ k create configmap app-config --from-literal=APP_COLOR=blue
- Create a configMap from file </br> $ k create configmap app-config --from-file=app-config.properities
- Create a secret from literal </br> $ k create secret app-secret --from-literal=APP_COLOR=blue
- Create a secret from file </br> $ k create secret app-secret --from-file=app-secret.properities
- Perform draining of nodes </br> $ k cordon node01 </br> $ k drain node01 </br> $ k uncordon node01
- Create a service account 'sa1' </br> $ k create sa sa1
- Check access </br> $ k auth can-i create deployments </br> $ k auth can-i delete nodes
- Check access for other users </br> $ k auth can-i create deployments --as dev-user -n default
- Identify namespaced and non namespaced resources </br> $ k api-resources --namespaced=true
- Inquire pod using jsonpath </br> $ k get pods -o=jsonpath='{ .items[0].spec.containers[0].image } {"\n"}{ .items[0].spec.containers[0].command }'   **# kubectl config view -h gives json path examples**
- Inquire context using filtering functionality of json query path </br> $ k config view --kubeconfig=my-kube-config -o=jsonpath="{ .contexts[?(@.context.user=='aws-user')].name}"   
    - Remember to use double quotes for jsonpath query when you use filter with single quotes inside the query
- To delete a pod without delay </br> $ k delete pod mypod --grace-period=0 --force
- To check authorization </br> $ k auth can-i get deploy -n blue --as dev-user
- To perform action on behalf of another user </br> $ kubectl get deploy -n blue --as dev-user
